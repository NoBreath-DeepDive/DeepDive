# 함수란?

- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 명령어의 묶음
- 특정 기능을 재사용 하고 싶을 때 작성
- 함수 요소들
    
    <img src="/week05/12장-1/images/1201.jpg" width="50%">
    
    - **매개변수**
        - 함수 내부로 입력을 전달받는 변수
        - 함수 몸체에셔 내부 변수로 사용한다.
    - **인수**
        - 호출시 매개변수로 전달되는 값
    - **반환값**
        - 최종 출력되는 값
    - **함수 정의**
        - 함수의 생성
        - 생성 방법은 여러가지가 있다. 뒤에서 소개…
    - **함수 호출**
        - 함수의 실행을 명시적으로 지시

# 함수를 사용하는 이유

- 코드의 재사용
    - 한 번 작성해놓은 함수를 몇 번이든 호출해서 사용 가능
- 유지보수의 편의성을 높임
    - 같은 기능의 중복된 코드가 여러개, 여러곳에 있다면
    한 가지의 수정을 위해서 걸리는 시간과 노력이 증가한다.
- 코드의 신뢰성을 높임
    - 실수를 줄여준다.

# 함수 리터럴

- 함수 리터럴 모습
    
    ```jsx
    // 변수에 함수 리터럴을 할당 (값으로 평가된다.)
    var f = function add(x, y){
    	return x + y;
    };
    ```
    
- 함수 리터럴 구성 요소
    
  <img src="/week05/12장-1/images/1204.jpg" width="50%">

- 함수는 객체다. (**함곧객**)
    - 일반 객체와는 다르게 호출이 가능하다.
- 자바스크립트 함수는 일급 객체이다.
    - 값의 성질을 갖기 때문
    - 일급 객체의 조건은?
        - 딥다이브
            - 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
            - 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
            - 함수의 매개변수에 전달할 수 있다.
            - 함수의 반환값으로 사용할 수 있다.
        - 용쌤 강의안
            - 변수, 배열 엘리먼트, 다른 객체의 프로퍼티에 할당될 수 있다.
            - 함수의 인자로 전달될 수 있다.
            - 함수의 결과값으로 반환될 수 있다.
            - 리터럴로 생성될 수 있다.
            - 동적으로 생성된 프로퍼티를 가질 수 있다.

# 함수 정의

- 함수 정의 한 눈에 보기
    
    <img src="/week05/12장-1/images/1202.png" width="50%">
    

## 함수 선언문

```jsx
function add(x, y) {
	return x + y;
}

console.log(add(2, 5)); // 7
```

- 함수 리터럴과 동일한 형태
- 함수 선언문은 함수 이름을 생략할 수 없다. (함수 리터럴은 가능)
- 함수 선언문은 표현식이 아닌 문이다.
- 변수에 할당할 수 없다.
    - 근데 변수에 할당이 되는 것 처럼 보인다
        
        ```jsx
        // 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
        // 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다
        var add = function add(x, y) {
        	return x + y;
        };
        
        // 함수 호출
        console.log(add(2, 5)); // 7
        ```
        
    - 왜?
        - 자바스크립트 엔진이 코드의 문맥에 따라 1) 함수 선언문, 2) 함수 리터럴 표현식
        두가지로 해석하기 때문
        - 사용되는 문맥에 따라 해석이 달라진다.
        - 두가지 해석은 함수를 생성하는 내부 동작에 차이가 있다.
    - 함수 리터럴로 해석되는 경우
        
        ```jsx
        // 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석
        // 함수 리터럴에서는 함수 이름을 생략할 수 있다.
        
        (function bar() { console.log('bar'); });
        bar(); // ReferenceError: bar is not defined
        ```
        
        - 그룹 연산자 ()의 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.
        따라서 표현식인 문인 함수 리터럴 표현식으로 해석 된다.
        - 함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자기 때문에
        bar()로 호출이 불가능 하다.
    - 함수 표현식으로 해석되는 경우
        
        ```jsx
        // 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
        // 함수 선언문에서는 함수 이름을 생략할 수 없다.
        
        function foo() { console.log('foo'); }
        
        foo(); // foo
        ```
        
        - 위 foo() 호출이 가능한 이유는
        자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고,
        거기에 함수 객체를 할당하기 때문이다.
        - 즉, 함수이름으로 호출한 것이 아니라 함수 객체를 가리키는 (암묵적으로 생성한)
        식별자로 호출하는 것이다.
            
            <img src="/week05/12장-1/images/1203.png" width="50%">
            

## 함수 표현식

```jsx
var add = function(x, y) { // 익명 함수
	return x + y;
};
```

- 함수 이름을 생략할 수 있다.
    - 익명 함수 라고 한다.
    - 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.
- 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 한다.

```jsx
// 기명 함수 표현식
var add = function foo (x, y) {
	return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
add(2, 5) // 7

// 함수 이름으로 호출하면 에러가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5)); // ReferenceError: foo is not defined
```

## 함수 생성 시점과 함수 호이스팅

```jsx
// 함수 참조
console.dir(add); // f add(x + y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)) // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 표현식
var sub = function(x, y) {
	return x - y;
};
```

- 함수 선언문
    - 함수 선언문 이전에 호출 가능
    - 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행
    → 런타임 이전에 함수 객체가 먼저 생성 된다.
        - 즉, 코드가 한 줄씩 실행되는 런타임에는 이미 함수 객체가 생성되어 있고 함수 일므과 동일한 식별자에 할당까지 완료된 상태이다.
        - 이렇게 끌어올려진 것 처럼 동작하는 특징 = 함수 호이스팅
    - 함수 호이스팅과 변수 호이스팅
        - 둘 다 자바스크립트 엔진에 의해 런타임 이전에 먼저 실행되어 식별자를 생성한다는 점에서는
        같다.
        - 변수 호이스팅은 undefined로 평가 되지만
        함수 호이스팅은 그대로 호출하여 사용이 가능하다.
- 함수 표현식
    - 함수 표현식 이전에 호출 불가능
    - 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.

## ~~Function 생성자 함수~~

```jsx
var add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5));
```

- Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.

## 화살표 함수(ES6)

```jsx
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

- 화살표 함수는 항상 익명 함수로 정의한다.
- 화살표 함수 특징
    - 생성자 함수로 사용할 수 없음
    - 기존 함수와 this 바인딩 방식이 다름
    - prototype 프로퍼티가 없음
    - arguments 객체를 생성하지 않음